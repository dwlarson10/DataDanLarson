'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attachEdgeIteratorCreator = attachEdgeIteratorCreator;
exports.attachEdgeIterationMethods = attachEdgeIterationMethods;

var _iterator = require('obliterator/iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _consume = require('obliterator/consume');

var _consume2 = _interopRequireDefault(_consume);

var _errors = require('../errors');

var _data = require('../data');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Graphology Edge Iteration
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * ==========================
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Attaching some methods to the Graph class to be able to iterate over a
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * graph's edges.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


/**
 * Definitions.
 */
var EDGES_ITERATION = [{
  name: 'edges',
  type: 'mixed'
}, {
  name: 'inEdges',
  type: 'directed',
  direction: 'in'
}, {
  name: 'outEdges',
  type: 'directed',
  direction: 'out'
}, {
  name: 'directedEdges',
  type: 'directed'
}, {
  name: 'undirectedEdges',
  type: 'undirected'
}];

/**
 * Helper classes.
 */

var EdgesIterator = function (_Iterator) {
  _inherits(EdgesIterator, _Iterator);

  function EdgesIterator() {
    _classCallCheck(this, EdgesIterator);

    return _possibleConstructorReturn(this, _Iterator.apply(this, arguments));
  }

  return EdgesIterator;
}(_iterator2.default);

/**
 * Function collecting edges from the given object.
 *
 * @param  {array}            edges  - Edges array to populate.
 * @param  {object|undefined} object - Target object.
 * @return {array}                   - The found edges.
 */


function collect(edges, object) {
  for (var k in object) {
    if (object[k] instanceof Set) edges.push.apply(edges, (0, _consume2.default)(object[k].values(), object[k].size));else edges.push(object[k]);
  }
}

/**
 * Function collecting edges from the given object at given key.
 *
 * @param  {array}            edges  - Edges array to populate.
 * @param  {object|undefined} object - Target object.
 * @param  {mixed}            key    - Neighbor key.
 * @return {array}                   - The found edges.
 */
function collectForKey(edges, object, key) {

  if (!(key in object)) return;

  if (object[key] instanceof Set) edges.push.apply(edges, (0, _consume2.default)(object[key].values(), object[key].size));else edges.push(object[key]);

  return;
}

/**
 * Function creating an array of edges for the given type.
 *
 * @param  {Graph}   graph - Target Graph instance.
 * @param  {string}  type  - Type of edges to retrieve.
 * @return {array}         - Array of edges.
 */
function createEdgeArray(graph, type) {
  if (graph.size === 0) return [];

  if (type === 'mixed') return (0, _consume2.default)(graph._edges.keys(), graph._edges.size);

  var list = [];

  graph._edges.forEach(function (data, edge) {

    if (data instanceof _data.UndirectedEdgeData === (type === 'undirected')) list.push(edge);
  });

  return list;
}

/**
 * Function creating an iterator of edges for the given type.
 *
 * @param  {Graph}    graph - Target Graph instance.
 * @param  {string}   type  - Type of edges to retrieve.
 * @return {Iterator}       - Edge iterator.
 */
function createEdgeIterator(graph, type) {
  if (graph.size === 0) return EdgesIterator.empty();

  var inner = void 0;

  if (type === 'mixed') {
    inner = graph._edges.keys();
    return new EdgesIterator(inner.next.bind(inner));
  }

  inner = graph._edges.entries();

  return new EdgesIterator(function next() {
    var step = inner.next();

    if (step.done) return step;

    var data = step.value[1];

    if (data instanceof _data.UndirectedEdgeData === (type === 'undirected')) return { value: step.value[0] };

    return next();
  });
}

/**
 * Function creating an array of edges for the given type & the given node.
 *
 * @param  {Graph}   graph     - Target Graph instance.
 * @param  {string}  type      - Type of edges to retrieve.
 * @param  {string}  direction - In or out?
 * @param  {any}     node      - Target node.
 * @return {array}             - Array of edges.
 */
function createEdgeArrayForNode(graph, type, direction, node) {
  var edges = [];

  var nodeData = graph._nodes.get(node);

  if (type !== 'undirected') {

    if (direction !== 'out') collect(edges, nodeData.in);
    if (direction !== 'in') collect(edges, nodeData.out);
  }

  if (type !== 'directed') {
    collect(edges, nodeData.undirected);
  }

  return edges;
}

/**
 * Function creating an array of edges for the given path.
 *
 * @param  {Graph}   graph  - Target Graph instance.
 * @param  {string}  type   - Type of edges to retrieve.
 * @param  {any}     source - Source node.
 * @param  {any}     target - Target node.
 * @return {array}          - Array of edges.
 */
function createEdgeArrayForPath(graph, type, source, target) {
  var edges = [];

  var sourceData = graph._nodes.get(source);

  if (type !== 'undirected') {
    collectForKey(edges, sourceData.in, target);
    collectForKey(edges, sourceData.out, target);
  }

  if (type !== 'directed') {
    collectForKey(edges, sourceData.undirected, target);
  }

  return edges;
}

/**
 * Function attaching an edge array creator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachEdgeArrayCreator(Class, description) {
  var name = description.name,
      type = description.type,
      direction = description.direction;

  /**
   * Function returning an array of certain edges.
   *
   * Arity 0: Return all the relevant edges.
   *
   * Arity 1a: Return all of a node's relevant edges.
   * @param  {any}   node   - Target node.
   *
   * Arity 1b: Return the union of the relevant edges of the given bunch of nodes.
   * @param  {bunch} bunch  - Bunch of nodes.
   *
   * Arity 2: Return the relevant edges across the given path.
   * @param  {any}   source - Source node.
   * @param  {any}   target - Target node.
   *
   * @return {array|number} - The edges or the number of edges.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */

  Class.prototype[name] = function (source, target) {

    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return [];

    if (!arguments.length) return createEdgeArray(this, type);

    if (arguments.length === 1) {
      source = '' + source;

      if (!this._nodes.has(source)) throw new _errors.NotFoundGraphError('Graph.' + name + ': could not find the "' + source + '" node in the graph.');

      // Iterating over a node's edges
      return createEdgeArrayForNode(this, type, direction, source);
    }

    if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      if (!this._nodes.has(source)) throw new _errors.NotFoundGraphError('Graph.' + name + ':  could not find the "' + source + '" source node in the graph.');

      if (!this._nodes.has(target)) throw new _errors.NotFoundGraphError('Graph.' + name + ':  could not find the "' + target + '" target node in the graph.');

      // Iterating over the edges between source & target
      var hasEdge = void 0;

      if (type !== 'undirected') hasEdge = this.hasDirectedEdge(source, target);else hasEdge = this.hasUndirectedEdge(source, target);

      // If no such edge exist, we'll stop right there.
      if (!hasEdge) return [];

      return createEdgeArrayForPath(this, type, source, target);
    }

    throw new _errors.InvalidArgumentsGraphError('Graph.' + name + ': too many arguments (expecting 0, 1 or 2 and got ' + arguments.length + ').');
  };
}

/**
 * Function attaching an edge array iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachEdgeIteratorCreator(Class, description) {
  var originalName = description.name,
      type = description.type;


  var name = originalName + 'Iterator';

  /**
   * Function returning an iterator over the graph's edges.
   *
   * Arity 0: Return all the relevant edges.
   *
   * Arity 1a: Return all of a node's relevant edges.
   * @param  {any}   node   - Target node.
   *
   * Arity 1b: Return the union of the relevant edges of the given bunch of nodes.
   * @param  {bunch} bunch  - Bunch of nodes.
   *
   * Arity 2: Return the relevant edges across the given path.
   * @param  {any}   source - Source node.
   * @param  {any}   target - Target node.
   *
   * @return {array|number} - The edges or the number of edges.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[name] = function () {

    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return _iterator2.default.empty();

    if (!arguments.length) return createEdgeIterator(this, type);

    // TODO: complete here...
    // if (arguments.length === 1) {
    //   source = '' + source;

    //   if (!this._nodes.has(source))
    //     throw new NotFoundGraphError(`Graph.${name}: could not find the "${source}" node in the graph.`);

    //   // Iterating over a node's edges
    //   return createEdgeArrayForNode(this, type, direction, source);
    // }

    // if (arguments.length === 2) {
    //   source = '' + source;
    //   target = '' + target;

    //   if (!this._nodes.has(source))
    //     throw new NotFoundGraphError(`Graph.${name}:  could not find the "${source}" source node in the graph.`);

    //   if (!this._nodes.has(target))
    //     throw new NotFoundGraphError(`Graph.${name}:  could not find the "${target}" target node in the graph.`);

    //   // Iterating over the edges between source & target
    //   let hasEdge;

    //   if (type !== 'undirected')
    //     hasEdge = this.hasDirectedEdge(source, target);
    //   else
    //     hasEdge = this.hasUndirectedEdge(source, target);

    //   // If no such edge exist, we'll stop right there.
    //   if (!hasEdge)
    //     return [];

    //   return createEdgeArrayForPath(this, type, source, target);
    // }

    // throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);
  };
}

/**
 * Function attaching every edge iteration method to the Graph class.
 *
 * @param {function} Graph - Graph class.
 */
function attachEdgeIterationMethods(Graph) {
  EDGES_ITERATION.forEach(function (description) {
    attachEdgeArrayCreator(Graph, description);
    attachEdgeIteratorCreator(Graph, description);
  });
}