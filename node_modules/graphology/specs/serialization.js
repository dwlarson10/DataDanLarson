'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = serialization;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Graphology Serializaton Specs
 * ==============================
 *
 * Testing the serialization methods of the graph.
 */
function serialization(Graph, checkers) {
  var invalid = checkers.invalid,
      notFound = checkers.notFound;


  return {
    '#.exportNode': {
      'it should throw if the node does not exist.': function itShouldThrowIfTheNodeDoesNotExist() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.exportNode('Test');
        }, notFound());
      },

      'it should properly serialize nodes.': function itShouldProperlySerializeNodes() {
        var graph = new Graph();
        graph.addNode('John');
        graph.addNode('Jack', { age: 34 });

        _assert2.default.deepEqual(graph.exportNode('John'), { key: 'John' });
        _assert2.default.deepEqual(graph.exportNode('Jack'), { key: 'Jack', attributes: { age: 34 } });
      }
    },

    '#.exportEdge': {
      'it should throw if the edge does not exist.': function itShouldThrowIfTheEdgeDoesNotExist() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.exportEdge('Test');
        }, notFound());
      },

      'it should properly serialize edges.': function itShouldProperlySerializeEdges() {
        var graph = new Graph({ multi: true });
        graph.addNodesFrom(['John', 'Martha']);
        graph.addEdgeWithKey('J->M•1', 'John', 'Martha');
        graph.addEdgeWithKey('J->M•2', 'John', 'Martha', { weight: 1 });
        graph.addUndirectedEdgeWithKey('J<->M•1', 'John', 'Martha');
        graph.addUndirectedEdgeWithKey('J<->M•2', 'John', 'Martha', { weight: 2 });

        _assert2.default.deepEqual(graph.exportEdge('J->M•1'), { key: 'J->M•1', source: 'John', target: 'Martha' });
        _assert2.default.deepEqual(graph.exportEdge('J->M•2'), { key: 'J->M•2', source: 'John', target: 'Martha', attributes: { weight: 1 } });
        _assert2.default.deepEqual(graph.exportEdge('J<->M•1'), { key: 'J<->M•1', source: 'John', target: 'Martha', undirected: true });
        _assert2.default.deepEqual(graph.exportEdge('J<->M•2'), { key: 'J<->M•2', source: 'John', target: 'Martha', attributes: { weight: 2 }, undirected: true });
      },

      'it should not include generated keys.': function itShouldNotIncludeGeneratedKeys() {
        var graph = new Graph();
        graph.addNodesFrom([1, 2, 3]);

        var edge1 = graph.addEdge(1, 2);
        var edge2 = graph.addEdgeWithKey('edge2', 2, 3);

        _assert2.default.deepEqual(graph.exportEdge(edge1), {
          source: '1',
          target: '2'
        });

        _assert2.default.deepEqual(graph.exportEdge(edge2), {
          source: '2',
          target: '3',
          key: 'edge2'
        });
      }
    },

    '#.exportNodes': {
      'it should throw if any of the provided nodes does not exist.': function itShouldThrowIfAnyOfTheProvidedNodesDoesNotExist() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.exportNodes(['Test']);
        }, notFound());
      },

      'it should return all the nodes serialized if no arguments are provided.': function itShouldReturnAllTheNodesSerializedIfNoArgumentsAreProvided() {
        var graph = new Graph();
        graph.addNode('John');
        graph.addNode('Jack', { age: 34 });

        _assert2.default.deepEqual(graph.exportNodes(), [{ key: 'John' }, { key: 'Jack', attributes: { age: 34 } }]);
      },

      'it should return the serialized nodes from the given bunch.': function itShouldReturnTheSerializedNodesFromTheGivenBunch() {
        var graph = new Graph();
        graph.addNodesFrom(['John', 'Jack', 'Martha']);

        (0, _helpers.testBunches)(['John', 'Martha'], function (bunch) {
          _assert2.default.deepEqual(graph.exportNodes(bunch), [{ key: 'John' }, { key: 'Martha' }]);
        });
      }
    },

    '#.exportEdges': {
      'it should throw if any of the provided edges does not exist.': function itShouldThrowIfAnyOfTheProvidedEdgesDoesNotExist() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.exportEdges(['Test']);
        }, notFound());
      },

      'it should return all the edges serialized if no arguments are provided.': function itShouldReturnAllTheEdgesSerializedIfNoArgumentsAreProvided() {
        var graph = new Graph({ multi: true });
        graph.addNode('John');
        graph.addNode('Jack');
        graph.addEdgeWithKey('J->J•1', 'John', 'Jack');
        graph.addEdgeWithKey('J->J•2', 'John', 'Jack', { weight: 2 });

        _assert2.default.deepEqual(graph.exportEdges(), [{ key: 'J->J•1', source: 'John', target: 'Jack' }, { key: 'J->J•2', source: 'John', target: 'Jack', attributes: { weight: 2 } }]);
      },

      'it should return the serialized edges from the given bunch.': function itShouldReturnTheSerializedEdgesFromTheGivenBunch() {
        var graph = new Graph({ multi: true });
        graph.addNodesFrom(['John', 'Jack', 'Martha']);
        graph.addEdgeWithKey('J->J•1', 'John', 'Jack');
        graph.addEdgeWithKey('J->J•2', 'John', 'Jack', { weight: 2 });
        graph.addEdgeWithKey('J->J•3', 'John', 'Jack');

        (0, _helpers.testBunches)(['J->J•1', 'J->J•3'], function (bunch) {
          _assert2.default.deepEqual(graph.exportEdges(bunch), [{ key: 'J->J•1', source: 'John', target: 'Jack' }, { key: 'J->J•3', source: 'John', target: 'Jack' }]);
        });
      }
    },

    '#.exportDirectedEdges': {
      'it should throw if any of the provided edges does not exist.': function itShouldThrowIfAnyOfTheProvidedEdgesDoesNotExist() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.exportDirectedEdges(['Test']);
        }, notFound());
      },

      'it should return all the directed edges serialized if no arguments are provided.': function itShouldReturnAllTheDirectedEdgesSerializedIfNoArgumentsAreProvided() {
        var graph = new Graph({ multi: true });
        graph.addNode('John');
        graph.addNode('Jack');
        graph.addEdgeWithKey('J->J•1', 'John', 'Jack');
        graph.addEdgeWithKey('J->J•2', 'John', 'Jack', { weight: 2 });
        graph.addUndirectedEdgeWithKey('J<->J•1', 'John', 'Jack');
        graph.addUndirectedEdgeWithKey('J<->J•2', 'John', 'Jack');

        _assert2.default.deepEqual(graph.exportDirectedEdges(), [{ key: 'J->J•1', source: 'John', target: 'Jack' }, { key: 'J->J•2', source: 'John', target: 'Jack', attributes: { weight: 2 } }]);
      },

      'it should return the serialized directed edges from the given bunch.': function itShouldReturnTheSerializedDirectedEdgesFromTheGivenBunch() {
        var graph = new Graph({ multi: true });
        graph.addNodesFrom(['John', 'Jack', 'Martha']);
        graph.addEdgeWithKey('J->J•1', 'John', 'Jack');
        graph.addEdgeWithKey('J->J•2', 'John', 'Jack', { weight: 2 });
        graph.addEdgeWithKey('J->J•3', 'John', 'Jack');
        graph.addUndirectedEdgeWithKey('J<->J•1', 'John', 'Jack');
        graph.addUndirectedEdgeWithKey('J<->J•2', 'John', 'Jack');

        (0, _helpers.testBunches)(['J->J•1', 'J->J•3', 'J<->J•2'], function (bunch) {
          _assert2.default.deepEqual(graph.exportDirectedEdges(bunch), [{ key: 'J->J•1', source: 'John', target: 'Jack' }, { key: 'J->J•3', source: 'John', target: 'Jack' }]);
        });
      }
    },

    '#.exportUndirectedEdges': {
      'it should throw if any of the provided edges does not exist.': function itShouldThrowIfAnyOfTheProvidedEdgesDoesNotExist() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.exportUndirectedEdges(['Test']);
        }, notFound());
      },

      'it should return all the undirected edges serialized if no arguments are provided.': function itShouldReturnAllTheUndirectedEdgesSerializedIfNoArgumentsAreProvided() {
        var graph = new Graph({ multi: true });
        graph.addNode('John');
        graph.addNode('Jack');
        graph.addEdgeWithKey('J->J•1', 'John', 'Jack');
        graph.addEdgeWithKey('J->J•2', 'John', 'Jack', { weight: 2 });
        graph.addUndirectedEdgeWithKey('J<->J•1', 'John', 'Jack');
        graph.addUndirectedEdgeWithKey('J<->J•2', 'John', 'Jack');

        _assert2.default.deepEqual(graph.exportUndirectedEdges(), [{ key: 'J<->J•1', source: 'John', target: 'Jack', undirected: true }, { key: 'J<->J•2', source: 'John', target: 'Jack', undirected: true }]);
      },

      'it should return the serialized undirected edges from the given bunch.': function itShouldReturnTheSerializedUndirectedEdgesFromTheGivenBunch() {
        var graph = new Graph({ multi: true });
        graph.addNodesFrom(['John', 'Jack', 'Martha']);
        graph.addEdgeWithKey('J->J•1', 'John', 'Jack');
        graph.addEdgeWithKey('J->J•2', 'John', 'Jack', { weight: 2 });
        graph.addEdgeWithKey('J->J•3', 'John', 'Jack');
        graph.addUndirectedEdgeWithKey('J<->J•1', 'John', 'Jack');
        graph.addUndirectedEdgeWithKey('J<->J•2', 'John', 'Jack');

        (0, _helpers.testBunches)(['J->J•1', 'J->J•3', 'J<->J•2'], function (bunch) {
          _assert2.default.deepEqual(graph.exportUndirectedEdges(bunch), [{ key: 'J<->J•2', source: 'John', target: 'Jack', undirected: true }]);
        });
      }
    },

    '#.export': {
      'it should correctly return the serialized graph.': function itShouldCorrectlyReturnTheSerializedGraph() {
        var graph = new Graph({ multi: true });
        graph.setAttribute('name', 'graph');
        graph.addNodesFrom(['John', 'Jack', 'Martha']);
        graph.setNodeAttribute('John', 'age', 34);
        graph.addEdgeWithKey('J->J•1', 'John', 'Jack');
        graph.addEdgeWithKey('J->J•2', 'John', 'Jack', { weight: 2 });
        graph.addEdgeWithKey('J->J•3', 'John', 'Jack');
        graph.addUndirectedEdgeWithKey('J<->J•1', 'John', 'Jack');
        graph.addUndirectedEdgeWithKey('J<->J•2', 'John', 'Jack', { weight: 3 });

        _assert2.default.deepEqual(graph.export(), {
          attributes: {
            name: 'graph'
          },
          nodes: [{ key: 'John', attributes: { age: 34 } }, { key: 'Jack' }, { key: 'Martha' }],
          edges: [{ key: 'J->J•1', source: 'John', target: 'Jack' }, { key: 'J->J•2', source: 'John', target: 'Jack', attributes: { weight: 2 } }, { key: 'J->J•3', source: 'John', target: 'Jack' }, { key: 'J<->J•1', source: 'John', target: 'Jack', undirected: true }, { key: 'J<->J•2', source: 'John', target: 'Jack', attributes: { weight: 3 }, undirected: true }]
        });
      }
    },

    '#.importNode': {
      'it should throw if the given serialized node is invalid.': function itShouldThrowIfTheGivenSerializedNodeIsInvalid() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.importNode(false);
        }, invalid());

        _assert2.default.throws(function () {
          graph.importNode({ hello: 'world' });
        }, invalid());

        _assert2.default.throws(function () {
          graph.importNode({ key: 'test', attributes: false });
        }, invalid());
      },

      'it should correctly import the given node.': function itShouldCorrectlyImportTheGivenNode() {
        var graph = new Graph();
        graph.importNode({ key: 'John' });
        graph.importNode({ key: 'Jack', attributes: { age: 34 } });

        _assert2.default.deepEqual(graph.nodes(), ['John', 'Jack']);
        _assert2.default.deepEqual(graph.getNodeAttributes('Jack'), { age: 34 });
      },

      'it should merge if the flag is true.': function itShouldMergeIfTheFlagIsTrue() {
        var graph = new Graph();
        graph.addNode('John');
        graph.importNode({ key: 'John', attributes: { age: 34 } }, true);

        _assert2.default.deepEqual(graph.nodes(), ['John']);
        _assert2.default.strictEqual(graph.getNodeAttribute('John', 'age'), 34);
      }
    },

    '#.importEdge': {
      'it should throw if the given serialized node is invalid.': function itShouldThrowIfTheGivenSerializedNodeIsInvalid() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.importEdge(false);
        }, invalid());

        _assert2.default.throws(function () {
          graph.importEdge({ hello: 'world' });
        }, invalid());

        _assert2.default.throws(function () {
          graph.importEdge({ source: 'John', hello: 'world' });
        }, invalid());

        _assert2.default.throws(function () {
          graph.importEdge({ source: 'John', target: 'Thomas', attributes: false });
        }, invalid());

        _assert2.default.throws(function () {
          graph.importEdge({ source: 'John', target: 'Thomas', undirected: 'test' });
        }, invalid());
      },

      'it should correctly import the given edge.': function itShouldCorrectlyImportTheGivenEdge() {
        var graph = new Graph({ multi: true });
        graph.addNodesFrom(['John', 'Thomas']);

        graph.importEdge({
          source: 'John',
          target: 'Thomas'
        });

        graph.importEdge({
          key: 'J<->T',
          source: 'John',
          target: 'Thomas',
          attributes: { weight: 2 },
          undirected: true
        });

        _assert2.default.strictEqual(graph.size, 2);
        _assert2.default.deepEqual(graph.getEdgeAttributes('J<->T'), { weight: 2 });
      },

      'it should merge if the flag is true.': function itShouldMergeIfTheFlagIsTrue() {
        var graph = new Graph();
        graph.addNodesFrom(['John', 'Thomas']);
        graph.addEdge('John', 'Thomas');

        graph.importEdge({ source: 'John', target: 'Thomas', attributes: { weight: 10 } }, true);

        _assert2.default.strictEqual(graph.size, 1);
        _assert2.default.strictEqual(graph.getEdgeAttribute('John', 'Thomas', 'weight'), 10);
      }
    },

    '#.importNodes': {
      'it should throw if not given an array.': function itShouldThrowIfNotGivenAnArray() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.importNodes({ hello: 'world' });
        }, invalid());
      },

      'it should correctly import the given nodes.': function itShouldCorrectlyImportTheGivenNodes() {
        var graph = new Graph();

        graph.importNodes([{ key: 'John' }, { key: 'Thomas', attributes: { age: 34 } }]);

        var nodes = graph.nodes();

        _assert2.default.deepEqual(nodes, ['John', 'Thomas']);
        _assert2.default.deepEqual(graph.getNodeAttributes('Thomas'), { age: 34 });
      }
    },

    '#.importEdges': {
      'it should throw if not given an array.': function itShouldThrowIfNotGivenAnArray() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.importEdges({ hello: 'world' });
        }, invalid());
      },

      'it should correctly import the given edges.': function itShouldCorrectlyImportTheGivenEdges() {
        var graph = new Graph();

        graph.addNodesFrom(['John', 'Thomas']);

        graph.importEdges([{
          source: 'John',
          target: 'Thomas'
        }, {
          key: 'J<->T',
          source: 'John',
          target: 'Thomas',
          attributes: { weight: 2 },
          undirected: true
        }]);

        _assert2.default.strictEqual(graph.size, 2);
        _assert2.default.deepEqual(graph.getEdgeAttributes('J<->T'), { weight: 2 });
      }
    },

    '#.import': {
      'it should throw if the given data is invalid.': function itShouldThrowIfTheGivenDataIsInvalid() {
        var graph = new Graph();

        _assert2.default.throws(function () {
          graph.import(true);
        }, invalid());
      },

      'it should be possible to import a graph instance.': function itShouldBePossibleToImportAGraphInstance() {
        var graph = new Graph();
        graph.addNodesFrom(['John', 'Thomas']);
        graph.addEdge('John', 'Thomas');

        var other = new Graph();
        other.import(graph);

        _assert2.default.deepEqual(graph.nodes(), other.nodes());
        _assert2.default.deepEqual(graph.edges(), other.edges());
      },

      'it should be possible to import a serialized graph.': function itShouldBePossibleToImportASerializedGraph() {
        var graph = new Graph();
        graph.import({
          nodes: [{ key: 'John' }, { key: 'Thomas' }],
          edges: [{ source: 'John', target: 'Thomas' }]
        });

        _assert2.default.deepEqual(graph.nodes(), ['John', 'Thomas']);
        _assert2.default.strictEqual(graph.hasEdge('John', 'Thomas'), true);
      },

      'it should be possible to import only edges when merging.': function itShouldBePossibleToImportOnlyEdgesWhenMerging() {
        var graph = new Graph();

        graph.import({
          edges: [{ source: 'John', target: 'Thomas' }]
        }, true);

        _assert2.default.deepEqual(graph.nodes(), ['John', 'Thomas']);
        _assert2.default.strictEqual(graph.size, 1);
        _assert2.default.strictEqual(graph.hasEdge('John', 'Thomas'), true);
      },

      'it should be possible to import attributes.': function itShouldBePossibleToImportAttributes() {
        var graph = new Graph();

        graph.import({
          attributes: {
            name: 'graph'
          }
        });

        _assert2.default.deepEqual(graph.getAttributes(), { name: 'graph' });
      }
    }
  };
}