'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = edgesIteration;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _consume = require('obliterator/consume');

var _consume2 = _interopRequireDefault(_consume);

var _helpers = require('../helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * Graphology Edges Iteration Specs
                                                                                                                                                                                                                   * =================================
                                                                                                                                                                                                                   *
                                                                                                                                                                                                                   * Testing the edges iteration-related methods of the graph.
                                                                                                                                                                                                                   */


var METHODS = ['edges', 'inEdges', 'outEdges', 'directedEdges', 'undirectedEdges'];

function edgesIteration(Graph, checkers) {
  var invalid = checkers.invalid,
      notFound = checkers.notFound;


  var graph = new Graph({ multi: true });

  graph.addNodesFrom(['John', 'Thomas', 'Martha', 'Roger', 'Catherine', 'Alone', 'Forever']);

  graph.addDirectedEdgeWithKey('J->T', 'John', 'Thomas');
  graph.addDirectedEdgeWithKey('J->M', 'John', 'Martha');
  graph.addDirectedEdgeWithKey('C->J', 'Catherine', 'John');

  graph.addUndirectedEdgeWithKey('M<->R', 'Martha', 'Roger');
  graph.addUndirectedEdgeWithKey('M<->J', 'Martha', 'John');
  graph.addUndirectedEdgeWithKey('J<->R', 'John', 'Roger');
  graph.addUndirectedEdgeWithKey('T<->M', 'Thomas', 'Martha');

  var ALL_EDGES = ['J->T', 'J->M', 'C->J', 'M<->R', 'M<->J', 'J<->R', 'T<->M'];

  var ALL_DIRECTED_EDGES = ['J->T', 'J->M', 'C->J'];

  var ALL_UNDIRECTED_EDGES = ['M<->R', 'M<->J', 'J<->R', 'T<->M'];

  var TEST_DATA = {
    edges: {
      all: ALL_EDGES,
      node: {
        key: 'John',
        edges: ['C->J', 'J->T', 'J->M', 'M<->J', 'J<->R']
      },
      bunch: {
        keys: ['Martha', 'Roger'],
        edges: ['J->M', 'M<->R', 'M<->J', 'T<->M', 'J<->R']
      },
      path: {
        source: 'John',
        target: 'Martha',
        edges: ['J->M', 'M<->J']
      }
    },
    inEdges: {
      all: ALL_DIRECTED_EDGES,
      node: {
        key: 'John',
        edges: ['C->J']
      },
      path: {
        source: 'John',
        target: 'Martha',
        edges: ['J->M']
      }
    },
    outEdges: {
      all: ALL_DIRECTED_EDGES,
      node: {
        key: 'John',
        edges: ['J->T', 'J->M']
      },
      path: {
        source: 'John',
        target: 'Martha',
        edges: ['J->M']
      }
    },
    directedEdges: {
      all: ALL_DIRECTED_EDGES,
      node: {
        key: 'John',
        edges: ['C->J', 'J->T', 'J->M']
      },
      path: {
        source: 'John',
        target: 'Martha',
        edges: ['J->M']
      }
    },
    undirectedEdges: {
      all: ALL_UNDIRECTED_EDGES,
      node: {
        key: 'John',
        edges: ['M<->J', 'J<->R']
      },
      path: {
        source: 'John',
        target: 'Martha',
        edges: ['M<->J']
      }
    }
  };

  function commonTests(name) {
    return _defineProperty({}, '#.' + name, {
      'it should throw if too many arguments are provided.': function itShouldThrowIfTooManyArgumentsAreProvided() {
        _assert2.default.throws(function () {
          graph[name](1, 2, 3);
        }, invalid());
      },

      'it should throw when the node is not found.': function itShouldThrowWhenTheNodeIsNotFound() {
        _assert2.default.throws(function () {
          graph[name]('Test');
        }, notFound());
      },

      'it should throw if either source or target is not found.': function itShouldThrowIfEitherSourceOrTargetIsNotFound() {
        _assert2.default.throws(function () {
          graph[name]('Test', 'Alone');
        }, notFound());

        _assert2.default.throws(function () {
          graph[name]('Alone', 'Test');
        }, notFound());
      }
    });
  }

  function specificTests(name, data) {
    return _defineProperty({}, '#.' + name, {
      'it should return all the relevant edges.': function itShouldReturnAllTheRelevantEdges() {
        var edges = graph[name]();

        _assert2.default.deepEqual(edges, data.all);
      },

      'it should be possible to return an iterator over the relevant edges.': function itShouldBePossibleToReturnAnIteratorOverTheRelevantEdges() {
        var iterator = graph[name + 'Iterator']();

        _assert2.default.deepEqual((0, _consume2.default)(iterator), data.all);
      },

      'it should return a node\'s relevant edges.': function itShouldReturnANodeSRelevantEdges() {
        var edges = graph[name](data.node.key);

        _assert2.default.deepEqual(edges, data.node.edges);
        _assert2.default.deepEqual(graph[name]('Alone'), []);
      },

      'it should return all the relevant edges between source & target.': function itShouldReturnAllTheRelevantEdgesBetweenSourceTarget() {
        var edges = graph[name](data.path.source, data.path.target);

        (0, _assert2.default)((0, _helpers.sameMembers)(edges, data.path.edges));
        _assert2.default.deepEqual(graph[name]('Forever', 'Alone'), []);
      }
    });
  }

  var tests = {
    'Miscellaneous': {
      'simple graph indices should work.': function simpleGraphIndicesShouldWork() {
        var simpleGraph = new Graph();
        simpleGraph.addNodesFrom([1, 2, 3, 4]);
        simpleGraph.addEdgeWithKey('1->2', 1, 2);
        simpleGraph.addEdgeWithKey('1->3', 1, 3);
        simpleGraph.addEdgeWithKey('1->4', 1, 4);

        _assert2.default.deepEqual(simpleGraph.edges(1), ['1->2', '1->3', '1->4']);
      }
    }
  };

  // Common tests
  METHODS.forEach(function (name) {
    return (0, _helpers.deepMerge)(tests, commonTests(name));
  });

  // Specific tests
  for (var name in TEST_DATA) {
    (0, _helpers.deepMerge)(tests, specificTests(name, TEST_DATA[name]));
  }return tests;
}